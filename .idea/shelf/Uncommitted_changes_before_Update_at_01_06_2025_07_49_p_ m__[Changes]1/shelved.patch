Index: app/src/main/java/com/app/tibibalance/ui/screens/auth/signin/SignInViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ui/screens/auth/signin/SignInViewModel.kt */\r\npackage com.app.tibibalance.ui.screens.auth.signin\r\n\r\nimport androidx.lifecycle.ViewModel\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.app.domain.error.AuthError\r\nimport com.app.domain.error.AuthResult\r\nimport com.app.domain.model.UserCredentials\r\nimport com.app.domain.usecase.auth.GoogleSignInUseCase\r\nimport com.app.domain.usecase.auth.SignInUseCase\r\nimport com.app.tibibalance.ui.components.utils.mapAuthErrorToMessage\r\nimport dagger.hilt.android.lifecycle.HiltViewModel\r\nimport kotlinx.coroutines.flow.MutableStateFlow\r\nimport kotlinx.coroutines.flow.StateFlow\r\nimport kotlinx.coroutines.launch\r\nimport javax.inject.Inject\r\n\r\n/**\r\n * @file        SignInViewModel.kt\r\n * @ingroup     ui_screens_auth_signin\r\n * @brief       ViewModel encargado del flujo de inicio de sesión (email y Google).\r\n *\r\n * @details\r\n *  - Consume [SignInUseCase] y [GoogleSignInUseCase] que devuelven [AuthResult].\r\n *  - Mantiene el estado de UI en un [MutableStateFlow] expuesto como [StateFlow].\r\n *  - Traduce todos los [AuthError] de dominio a [SignInUiState.Error] usando [mapAuthErrorToMessage].\r\n *\r\n * @see SignInUiState Estados posibles de la UI en esta pantalla.\r\n */\r\n@HiltViewModel\r\nclass SignInViewModel @Inject constructor(\r\n    private val signInUseCase: SignInUseCase,\r\n    private val googleUseCase: GoogleSignInUseCase\r\n) : ViewModel() {\r\n\r\n    /** Estado observable para la pantalla de inicio de sesión. */\r\n    private val _ui = MutableStateFlow<SignInUiState>(SignInUiState.Idle)\r\n    val ui: StateFlow<SignInUiState> = _ui\r\n\r\n    /* ──────────────── E-mail / contraseña ──────────────── */\r\n\r\n    /**\r\n     * Inicia el proceso de login con email y contraseña.\r\n     *\r\n     * 1) Valida localmente los campos: correo no vacío/formato válido, contraseña no vacía.\r\n     * 2) Emite [SignInUiState.Loading] mientras espera la respuesta de [signInUseCase].\r\n     * 3) Si el resultado es exitoso, emite [SignInUiState.Success(res.data)] donde res.data es Boolean.\r\n     * 4) Si hay error, traduce el [AuthError] en un mensaje con emojis usando [mapAuthErrorToMessage]\r\n     *    y emite [SignInUiState.Error(mensaje)].\r\n     *\r\n     * @param email Correo ingresado por el usuario.\r\n     * @param pass  Contraseña ingresada por el usuario.\r\n     */\r\n    fun signIn(email: String, pass: String) = viewModelScope.launch {\r\n        // 1) Validación cliente\r\n        val emailErr = when {\r\n            email.isBlank() -> \"✏\uFE0F El correo es obligatorio\"\r\n            !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()\r\n                -> \"\uD83D\uDCE7 Formato de correo inválido\"\r\n            else -> null\r\n        }\r\n        val passErr = if (pass.isBlank()) \"✏\uFE0F La contraseña es obligatoria\" else null\r\n\r\n        if (emailErr != null || passErr != null) {\r\n            _ui.value = SignInUiState.FieldError(emailError = emailErr, passError = passErr)\r\n            return@launch\r\n        }\r\n\r\n        // 2) Lógica de negocio\r\n        _ui.value = SignInUiState.Loading\r\n        when (val res = signInUseCase(UserCredentials(email.trim(), pass))) {\r\n            is AuthResult.Success -> {\r\n                // Aquí res.data es un Boolean que indica si el correo está verificado\r\n                _ui.value = SignInUiState.Success(res.data)\r\n            }\r\n            is AuthResult.Error -> {\r\n                // 3) Usamos el mapeador global para todos los AuthError\r\n                val mensaje = mapAuthErrorToMessage(res.error)\r\n                _ui.value = SignInUiState.Error(mensaje)\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ──────────────── Google One-Tap ───────────────────── */\r\n\r\n    /**\r\n     * Completa el flujo One-Tap de Google y traduce errores.\r\n     *\r\n     * 1) Emite [SignInUiState.Loading] mientras espera la respuesta de [googleUseCase].\r\n     * 2) Si es exitoso, emite [SignInUiState.Success(true)] asumiendo que Google regresa verificado = true.\r\n     * 3) Si hay error, traduce el [AuthError] a mensaje usando [mapAuthErrorToMessage]\r\n     *    y emite [SignInUiState.Error(mensaje)].\r\n     *\r\n     * @param idToken Token JWT recibido de Google One-Tap.\r\n     */\r\n    fun finishGoogleSignIn(idToken: String) = viewModelScope.launch {\r\n        _ui.value = SignInUiState.Loading\r\n\r\n        when (val res = googleUseCase(idToken)) {\r\n            is AuthResult.Success -> {\r\n                // Se asume que toda autenticación con Google implica usuario verificado\r\n                _ui.value = SignInUiState.Success(true)\r\n            }\r\n            is AuthResult.Error -> {\r\n                val mensaje = mapAuthErrorToMessage(res.error)\r\n                _ui.value = SignInUiState.Error(mensaje)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Reinicia el estado para descartar errores ya mostrados. */\r\n    fun consumeError() {\r\n        _ui.value = SignInUiState.Idle\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/app/tibibalance/ui/screens/auth/signin/SignInViewModel.kt b/app/src/main/java/com/app/tibibalance/ui/screens/auth/signin/SignInViewModel.kt
--- a/app/src/main/java/com/app/tibibalance/ui/screens/auth/signin/SignInViewModel.kt	(revision 979eee6da0a8757dbe64d11a9dd3d4b50d6ffafa)
+++ b/app/src/main/java/com/app/tibibalance/ui/screens/auth/signin/SignInViewModel.kt	(date 1748818171377)
@@ -9,6 +9,7 @@
 import com.app.domain.usecase.auth.GoogleSignInUseCase
 import com.app.domain.usecase.auth.SignInUseCase
 import com.app.tibibalance.ui.components.utils.mapAuthErrorToMessage
+import com.google.firebase.auth.FirebaseAuth
 import dagger.hilt.android.lifecycle.HiltViewModel
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
@@ -99,6 +100,10 @@
         when (val res = googleUseCase(idToken)) {
             is AuthResult.Success -> {
                 // Se asume que toda autenticación con Google implica usuario verificado
+                val userId = FirebaseAuth.getInstance().currentUser?.uid
+                if (userId != null) {
+                    //initializeAchievementsUseCase(userId)
+                }
                 _ui.value = SignInUiState.Success(true)
             }
             is AuthResult.Error -> {
