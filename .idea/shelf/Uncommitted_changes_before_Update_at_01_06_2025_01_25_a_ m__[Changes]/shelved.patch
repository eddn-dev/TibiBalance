Index: app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ui/screens/settings/SettingsScreen.kt */\r\npackage com.app.tibibalance.ui.screens.settings\r\n\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.foundation.layout.Column\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.layout.size\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.verticalScroll\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.automirrored.filled.ListAlt\r\nimport androidx.compose.material.icons.filled.Description\r\nimport androidx.compose.material.icons.filled.NotificationsActive\r\nimport androidx.compose.material.icons.filled.NotificationsNone\r\nimport androidx.compose.material.icons.filled.Palette\r\nimport androidx.compose.material.icons.filled.Person\r\nimport androidx.compose.material.icons.filled.PrivacyTip\r\nimport androidx.compose.material.icons.filled.RecordVoiceOver\r\nimport androidx.compose.material.icons.filled.StarOutline\r\nimport androidx.compose.material3.AlertDialog\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.MaterialTheme\r\nimport androidx.compose.material3.SnackbarHost\r\nimport androidx.compose.material3.SnackbarHostState\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TextButton\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.LaunchedEffect\r\nimport androidx.compose.runtime.collectAsState\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableStateOf\r\nimport androidx.compose.runtime.remember\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.graphics.vector.ImageVector\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.hilt.navigation.compose.hiltViewModel\r\nimport androidx.navigation.NavHostController\r\nimport com.app.domain.entities.User\r\nimport com.app.domain.enums.ThemeMode\r\nimport com.app.tibibalance.R\r\nimport com.app.tibibalance.ui.components.buttons.DangerButton\r\nimport com.app.tibibalance.ui.components.buttons.SwitchToggle\r\nimport com.app.tibibalance.ui.components.containers.FormContainer\r\nimport com.app.tibibalance.ui.components.containers.ImageContainer\r\nimport com.app.tibibalance.ui.components.texts.Description\r\nimport com.app.tibibalance.ui.components.texts.Title\r\nimport com.app.tibibalance.ui.components.utils.SettingItem\r\nimport com.app.tibibalance.ui.navigation.Screen\r\nimport com.app.tibibalance.ui.theme.AccountSettings\r\nimport com.app.tibibalance.ui.theme.BluePrimaryLight\r\nimport com.app.tibibalance.ui.theme.LegalSettings\r\nimport com.app.tibibalance.ui.theme.PreferencesSettings\r\nimport com.app.tibibalance.ui.theme.gradient\r\n\r\n/* ─────────────────────────  Entry  ─────────────────────────── */\r\n\r\n@Composable\r\nfun SettingsScreen(\r\n    navController: NavHostController\r\n) {\r\n    val vm: SettingsViewModel = hiltViewModel()\r\n    val ui by vm.ui.collectAsState()\r\n\r\n    /* Navegación a Launch cuando se cierre sesión */\r\n    LaunchedEffect(Unit) {\r\n        vm.loggedOut.collect {\r\n            navController.navigate(Screen.Launch.route) {\r\n                popUpTo(Screen.Launch.route) { inclusive = true }\r\n                launchSingleTop = true\r\n            }\r\n        }\r\n    }\r\n\r\n    when {\r\n        ui.loading       -> Centered(\"Cargando…\")\r\n        ui.error != null -> Centered(ui.error!!)\r\n        ui.user != null  -> SettingsContent(\r\n            user                 = ui.user!!,\r\n            navController        = navController,\r\n            signingOut           = ui.signingOut,\r\n            /* VM callbacks */\r\n            onChangeTheme        = vm::changeTheme,\r\n            onToggleGlobalNotif  = vm::toggleGlobalNotif,\r\n            onToggleTTS          = vm::toggleTTS,\r\n            onSignOut            = vm::signOut\r\n        )\r\n    }\r\n}\r\n\r\n/* ────────────────────  Contenedor top-level  ─────────────────── */\r\n\r\n@Composable\r\nprivate fun SettingsContent(\r\n    user                : User,\r\n    navController       : NavHostController,\r\n    signingOut          : Boolean,\r\n    /* VM callbacks */\r\n    onChangeTheme       : (ThemeMode) -> Unit,\r\n    onToggleGlobalNotif : (Boolean) -> Unit,\r\n    onToggleTTS         : (Boolean) -> Unit,\r\n    onSignOut           : () -> Unit\r\n) {\r\n    /* Destinos secundarios */\r\n    val onEditPersonal   = { navController.navigate(Screen.EditProfile.route) }\r\n    val onConfigureNotis = { navController.navigate(Screen.ConfigureNotif.route) }\r\n\r\n    Box(\r\n        Modifier\r\n            .fillMaxSize()\r\n            .background(gradient)\r\n    ) {\r\n\r\n        SettingsBody(\r\n            user                 = user,\r\n            onEditPersonal       = onEditPersonal,\r\n            onDevices            = { /* TODO */ },\r\n            onAchievements       = {navController.navigate(Screen.Achievements.route) },\r\n            onConfigureNotis     = onConfigureNotis,\r\n            onChangeTheme        = onChangeTheme,\r\n            onToggleGlobalNotif  = onToggleGlobalNotif,\r\n            onToggleTTS          = onToggleTTS,\r\n            onSignOut            = onSignOut,\r\n            signingOut           = signingOut,\r\n            onDeleteAccount      = { /* TODO */ },\r\n            onOpenTerms          = { /* TODO */ },\r\n            onOpenPrivacy        = { /* TODO */ }\r\n        )\r\n    }\r\n}\r\n\r\n/* ───────────────────────  Cuerpo scrollable ─────────────────── */\r\n\r\n@Composable\r\nprivate fun SettingsBody(\r\n    user               : User,\r\n    /* Cuenta */\r\n    onEditPersonal     : () -> Unit,\r\n    onDevices          : () -> Unit,\r\n    onAchievements     : () -> Unit,\r\n    onConfigureNotis   : () -> Unit,\r\n    /* Preferencias */\r\n    onChangeTheme      : (ThemeMode) -> Unit,\r\n    onToggleGlobalNotif: (Boolean) -> Unit,\r\n    onToggleTTS        : (Boolean) -> Unit,\r\n    onOpenTerms        : () -> Unit,\r\n    onOpenPrivacy      : () -> Unit,\r\n    /* Sesión */\r\n    onSignOut          : () -> Unit,\r\n    signingOut         : Boolean,\r\n    onDeleteAccount    : () -> Unit\r\n) {\r\n    /* diálogos */\r\n    val snackbar = remember { SnackbarHostState() }\r\n    var showDeleteDialog by remember { mutableStateOf(false) }\r\n\r\n    if (showDeleteDialog) {\r\n        AlertDialog(\r\n            onDismissRequest = { showDeleteDialog = false },\r\n            title           = { Text(\"Eliminar cuenta\") },\r\n            text            = { Text(\"¿Seguro? Esta acción es irreversible.\") },\r\n            confirmButton   = {\r\n                TextButton(\r\n                    onClick = { onDeleteAccount(); showDeleteDialog = false }\r\n                ) { Text(\"Eliminar\", color = MaterialTheme.colorScheme.error) }\r\n            },\r\n            dismissButton   = {\r\n                TextButton(onClick = { showDeleteDialog = false }) { Text(\"Cancelar\") }\r\n            }\r\n        )\r\n    }\r\n\r\n    /* estado local para switches/botones – sincronizado con el VM */\r\n    val settings = user.settings\r\n    var theme     by remember { mutableStateOf(settings.theme) }\r\n    var notifGlob by remember { mutableStateOf(settings.notifGlobal) }\r\n    var tts       by remember { mutableStateOf(settings.accessibilityTTS) }\r\n\r\n    Column(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .verticalScroll(rememberScrollState())\r\n            .padding(top = 96.dp, start = 24.dp, end = 24.dp, bottom = 24.dp),\r\n        horizontalAlignment = Alignment.CenterHorizontally,\r\n        verticalArrangement = Arrangement.spacedBy(24.dp)\r\n    ) {\r\n        ImageContainer(\r\n            resId = R.drawable.ic_settings,\r\n            contentDescription = \"Configuracion\",\r\n            modifier = Modifier.size(128.dp)\r\n        )\r\n        Title(\r\n            text = \"Configuración\",\r\n        )\r\n        /* ── Grupo: Cuenta ── */\r\n        FormContainer(backgroundColor = AccountSettings) {\r\n            SettingItem(\r\n                leadingIcon = { Icon24(Icons.AutoMirrored.Filled.ListAlt) },\r\n                text        = \"Editar información personal\",\r\n                onClick     = onEditPersonal\r\n            )\r\n            SettingItem(\r\n                leadingIcon = { Icon24(Icons.Default.Person) },\r\n                text        = \"Administrar dispositivos\",\r\n                onClick     = onDevices\r\n            )\r\n            SettingItem(\r\n                leadingIcon = { Icon24(Icons.Default.StarOutline) },\r\n                text        = \"Logros y rachas\",\r\n                onClick     = onAchievements\r\n            )\r\n            SettingItem(\r\n                leadingIcon = { Icon24(Icons.Default.NotificationsNone) },\r\n                text        = \"Configurar notificaciones\",\r\n                onClick     = onConfigureNotis\r\n            )\r\n        }\r\n\r\n        /* ── Grupo: Preferencias ── */\r\n        FormContainer(backgroundColor = PreferencesSettings) {\r\n            SettingItem(\r\n                leadingIcon = { Icon24(Icons.Default.Palette) },\r\n                text        = \"Tema: ${theme.label()}\",\r\n                onClick     = {\r\n                    theme = theme.next().also(onChangeTheme)\r\n                }\r\n            )\r\n            SwitchSettingItem(\r\n                leadingIcon      = { Icon24(Icons.Default.NotificationsActive) },\r\n                text             = \"Notificaciones globales\",\r\n                checked          = notifGlob,\r\n                onCheckedChange  = {\r\n                    notifGlob = it\r\n                    onToggleGlobalNotif(it)\r\n                }\r\n            )\r\n            SwitchSettingItem(\r\n                leadingIcon      = { Icon24(Icons.Default.RecordVoiceOver) },\r\n                text             = \"Texto a voz (TTS)\",\r\n                checked          = tts,\r\n                onCheckedChange  = {\r\n                    tts = it\r\n                    onToggleTTS(it)\r\n                }\r\n            )\r\n        }\r\n\r\n        /* ── Grupo: Legal ── */\r\n        FormContainer(backgroundColor = LegalSettings) {\r\n            SettingItem(\r\n                leadingIcon = { Icon24(Icons.Default.Description) },\r\n                text        = \"Términos de uso\",\r\n                onClick     = onOpenTerms\r\n            )\r\n            SettingItem(\r\n                leadingIcon = { Icon24(Icons.Default.PrivacyTip) },\r\n                text        = \"Política de privacidad\",\r\n                onClick     = onOpenPrivacy\r\n            )\r\n        }\r\n\r\n        /* ── Sesión ── */\r\n        Row(\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .padding(vertical = 8.dp),\r\n            horizontalArrangement = Arrangement.spacedBy(12.dp)\r\n        ) {\r\n            DangerButton(\r\n                text     = if (signingOut) \"Cerrando…\" else \"Cerrar sesión\",\r\n                onClick  = onSignOut,\r\n                enabled  = !signingOut,\r\n                modifier = Modifier.weight(1f)\r\n            )\r\n            DangerButton(\r\n                text     = \"Eliminar cuenta\",\r\n                onClick  = { showDeleteDialog = true },\r\n                modifier = Modifier.weight(1f)\r\n            )\r\n        }\r\n    }\r\n\r\n    SnackbarHost(snackbar)\r\n}\r\n\r\n/* ───────────────────── Helpers ───────────────────── */\r\n\r\n@Composable\r\nprivate fun Icon24(icon: ImageVector) =\r\n    Icon(icon, contentDescription = null, tint = BluePrimaryLight, modifier = Modifier.size(24.dp))\r\n\r\n@Composable\r\nprivate fun SwitchSettingItem(\r\n    leadingIcon     : @Composable () -> Unit,\r\n    text            : String,\r\n    checked         : Boolean,\r\n    onCheckedChange : (Boolean) -> Unit\r\n) = SettingItem(\r\n    leadingIcon = leadingIcon,\r\n    text        = text,\r\n    trailing    = { SwitchToggle(checked = checked, onCheckedChange = onCheckedChange) }\r\n)\r\n\r\n/* extensiones ThemeMode */\r\nprivate fun ThemeMode.label() = when (this) {\r\n    ThemeMode.SYSTEM -> \"Sistema\"\r\n    ThemeMode.LIGHT  -> \"Claro\"\r\n    ThemeMode.DARK   -> \"Oscuro\"\r\n}\r\nprivate fun ThemeMode.next() = when (this) {\r\n    ThemeMode.SYSTEM -> ThemeMode.LIGHT\r\n    ThemeMode.LIGHT  -> ThemeMode.DARK\r\n    ThemeMode.DARK   -> ThemeMode.SYSTEM\r\n}\r\n\r\n@Composable\r\nprivate fun Centered(msg: String) =\r\n    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\r\n        Description(msg)\r\n    }\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsScreen.kt b/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsScreen.kt
--- a/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsScreen.kt	(revision 889c681cbf682cefeecddf8b736a6c46c8572918)
+++ b/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsScreen.kt	(date 1748762530110)
@@ -110,6 +110,7 @@
     /* Destinos secundarios */
     val onEditPersonal   = { navController.navigate(Screen.EditProfile.route) }
     val onConfigureNotis = { navController.navigate(Screen.ConfigureNotif.route) }
+    val vm: SettingsViewModel = hiltViewModel()
 
     Box(
         Modifier
@@ -128,7 +129,7 @@
             onToggleTTS          = onToggleTTS,
             onSignOut            = onSignOut,
             signingOut           = signingOut,
-            onDeleteAccount      = { /* TODO */ },
+            onDeleteAccount      = vm::deleteAccount,
             onOpenTerms          = { /* TODO */ },
             onOpenPrivacy        = { /* TODO */ }
         )
Index: app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ui/screens/settings/SettingsViewModel.kt */\r\npackage com.app.tibibalance.ui.screens.settings\r\n\r\nimport androidx.lifecycle.ViewModel\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.app.domain.entities.User\r\nimport com.app.domain.entities.UserSettings\r\nimport com.app.domain.enums.ThemeMode\r\nimport com.app.domain.repository.AuthRepository\r\nimport com.app.domain.usecase.auth.SignOutUseCase\r\nimport com.app.domain.usecase.user.ObserveUser\r\nimport com.app.domain.usecase.user.UpdateUserSettings        // ⬅\uFE0F nuevo\r\nimport com.app.tibibalance.ui.theme.ThemeController\r\nimport dagger.hilt.android.lifecycle.HiltViewModel\r\nimport kotlinx.coroutines.flow.*\r\nimport kotlinx.coroutines.launch\r\nimport javax.inject.Inject\r\n\r\n@HiltViewModel\r\nclass SettingsViewModel @Inject constructor(\r\n    authRepo           : AuthRepository,\r\n    observeUser        : ObserveUser,\r\n    private val update : UpdateUserSettings,\r\n    private val theme  : ThemeController,\r\n    private val signOutUseCase: SignOutUseCase\r\n) : ViewModel() {\r\n\r\n    /* ---------- UI ---------- */\r\n    data class UiState(\r\n        val loading   : Boolean = true,\r\n        val user      : User?   = null,\r\n        val error     : String? = null,\r\n        val signingOut: Boolean = false\r\n    )\r\n\r\n    /* logout one-shot */\r\n    private val _loggedOut = MutableSharedFlow<Unit>(replay = 0, extraBufferCapacity = 1)\r\n    val  loggedOut: SharedFlow<Unit> = _loggedOut\r\n\r\n    private val _ui = MutableStateFlow(UiState())\r\n    val ui: StateFlow<UiState> = _ui.asStateFlow()\r\n\r\n    init {\r\n        /* observa cambios de sesión y del documento de usuario */\r\n        authRepo.authState()\r\n            .flatMapLatest { uid ->\r\n                if (uid == null) {\r\n                    _loggedOut.tryEmit(Unit)\r\n                    flowOf<User?>(null)\r\n                } else observeUser(uid)\r\n            }\r\n            .onEach { usr ->\r\n                _ui.value = if (usr == null)\r\n                    UiState(error = \"Sin sesión\")\r\n                else\r\n                    UiState(loading = false, user = usr)\r\n            }\r\n            .catch { e -> _ui.value = UiState(loading = false, error = e.message) }\r\n            .launchIn(viewModelScope)\r\n    }\r\n\r\n    /* --------- acciones --------- */\r\n\r\n    fun changeTheme(mode: ThemeMode) {\r\n        theme.setMode(mode)\r\n        persist { old -> old.copy(\r\n            settings = old.settings.copy(theme = mode)\r\n        )}\r\n    }\r\n\r\n    fun toggleGlobalNotif(enabled: Boolean) = persist { old ->\r\n        old.copy(settings = old.settings.copy(notifGlobal = enabled))\r\n    }\r\n\r\n    fun toggleTTS(enabled: Boolean) = persist { old ->\r\n        old.copy(settings = old.settings.copy(accessibilityTTS = enabled))\r\n    }\r\n\r\n    /** Aplica la transformación y la sube a Firestore/Room */\r\n    private fun persist(transform: (User) -> User) = viewModelScope.launch {\r\n        val current = _ui.value.user ?: return@launch\r\n        val updated = transform(current)\r\n\r\n        /* Optimistic UI */\r\n        _ui.value = _ui.value.copy(user = updated)\r\n\r\n        /* Persiste settings únicamente */\r\n        update(current.uid, updated.settings)\r\n            .onFailure { ex ->\r\n                // Revertir local si falla\r\n                _ui.value = _ui.value.copy(user = current, error = ex.message)\r\n            }\r\n    }\r\n\r\n    fun signOut() = viewModelScope.launch {\r\n        _ui.update { it.copy(signingOut = true) }\r\n        signOutUseCase()\r\n        _ui.update { it.copy(signingOut = false) }\r\n        /* authState() emitirá null → _loggedOut */\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsViewModel.kt b/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsViewModel.kt
--- a/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsViewModel.kt	(revision 889c681cbf682cefeecddf8b736a6c46c8572918)
+++ b/app/src/main/java/com/app/tibibalance/ui/screens/settings/SettingsViewModel.kt	(date 1748762265559)
@@ -7,6 +7,7 @@
 import com.app.domain.entities.UserSettings
 import com.app.domain.enums.ThemeMode
 import com.app.domain.repository.AuthRepository
+import com.app.domain.usecase.auth.DeleteAccountUseCase
 import com.app.domain.usecase.auth.SignOutUseCase
 import com.app.domain.usecase.user.ObserveUser
 import com.app.domain.usecase.user.UpdateUserSettings        // ⬅️ nuevo
@@ -22,7 +23,8 @@
     observeUser        : ObserveUser,
     private val update : UpdateUserSettings,
     private val theme  : ThemeController,
-    private val signOutUseCase: SignOutUseCase
+    private val signOutUseCase: SignOutUseCase,
+    private val deleteAccountUseCase: DeleteAccountUseCase
 ) : ViewModel() {
 
     /* ---------- UI ---------- */
@@ -98,4 +100,16 @@
         _ui.update { it.copy(signingOut = false) }
         /* authState() emitirá null → _loggedOut */
     }
+
+    fun deleteAccount() = viewModelScope.launch {
+        _ui.update { it.copy(loading = true) }
+        val result = deleteAccountUseCase()
+        _ui.update { it.copy(loading = false) }
+
+        if (result.isSuccess) {
+            _loggedOut.tryEmit(Unit)  // navega a pantalla de inicio
+        } else {
+            _ui.update { it.copy(error = result.exceptionOrNull()?.message) }
+        }
+    }
 }
Index: app/src/main/java/com/app/tibibalance/ui/screens/profile/show/ViewProfileScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ui/screens/profile/ViewProfileScreen.kt */\r\npackage com.app.tibibalance.ui.screens.profile.show\r\n\r\nimport android.os.Build\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.foundation.layout.Column\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.Spacer\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.height\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.layout.size\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.shape.CircleShape\r\nimport androidx.compose.foundation.verticalScroll\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.collectAsState\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.draw.clip\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.hilt.navigation.compose.hiltViewModel\r\nimport androidx.navigation.NavHostController\r\nimport coil3.compose.AsyncImage\r\nimport com.app.tibibalance.R\r\nimport com.app.tibibalance.ui.components.buttons.SecondaryButton\r\nimport com.app.tibibalance.ui.components.containers.FormContainer\r\nimport com.app.tibibalance.ui.components.containers.ImageContainer\r\nimport com.app.tibibalance.ui.components.containers.ProfileContainer\r\nimport com.app.tibibalance.ui.components.inputs.InputText\r\nimport com.app.tibibalance.ui.components.texts.Description\r\nimport com.app.tibibalance.ui.components.texts.Subtitle\r\nimport com.app.tibibalance.ui.navigation.Screen\r\nimport com.app.tibibalance.ui.theme.gradient\r\nimport kotlinx.datetime.toJavaLocalDate\r\nimport java.time.format.DateTimeFormatter\r\n\r\n@RequiresApi(Build.VERSION_CODES.O)\r\n@Composable\r\nfun ViewProfileScreen(\r\n    navController: NavHostController,\r\n    vm: ViewProfileViewModel = hiltViewModel()\r\n) {\r\n    val ui by vm.ui.collectAsState()\r\n\r\n    Box(\r\n        Modifier\r\n            .fillMaxSize()\r\n            .background(gradient)\r\n    ) {\r\n        when {\r\n            ui.loading -> Centered(\"Cargando…\")\r\n\r\n            ui.error != null -> Centered(ui.error!!)\r\n\r\n            ui.user != null -> ProfileContent(\r\n                user = ui.user!!,\r\n                onEdit = { navController.navigate(Screen.EditProfile.route) },\r\n                onSignOut = vm::signOut\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n@RequiresApi(Build.VERSION_CODES.O)\r\n@Composable\r\nprivate fun ProfileContent(\r\n    user      : com.app.domain.entities.User,\r\n    onEdit    : () -> Unit,\r\n    onSignOut : () -> Unit\r\n) {\r\n    Column(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .verticalScroll(rememberScrollState())\r\n            .padding(horizontal = 16.dp, vertical = 24.dp),\r\n        horizontalAlignment = Alignment.CenterHorizontally\r\n    ) {\r\n        Spacer(Modifier.height(10.dp))\r\n\r\n        FormContainer {\r\n\r\n            if (user.photoUrl != null) {\r\n                AsyncImage(\r\n                    model = user.photoUrl,\r\n                    contentDescription = \"Imagen de perfil\",\r\n                    modifier = Modifier\r\n                        .size(120.dp)\r\n                        .clip(CircleShape),\r\n                )\r\n            }\r\n            else {\r\n                ProfileContainer(\r\n                    imageResId = R.drawable.avatar_placeholder,\r\n                    size = 120.dp,\r\n                    modifier = Modifier\r\n                        .size(120.dp)\r\n                        .clip(CircleShape),\r\n                )\r\n                Spacer(Modifier.height(10.dp))\r\n            }\r\n\r\n            Spacer(Modifier.height(2.dp))\r\n\r\n            /* ---- nombre ---- */\r\n            Subtitle(text = user.displayName ?: \"Sin nombre\")\r\n\r\n            Spacer(Modifier.height(20.dp))\r\n\r\n            /* ---- fecha nacimiento ---- */\r\n            Subtitle(text = \"Fecha de nacimiento:\")\r\n            val dateFmt = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\")\r\n            InputText(\r\n                value         = user.birthDate.toJavaLocalDate().format(dateFmt),\r\n                onValueChange = {},            // sólo lectura\r\n                modifier      = Modifier\r\n                    .fillMaxWidth()\r\n                    .padding(top = 8.dp)\r\n            )\r\n\r\n            Spacer(Modifier.height(10.dp))\r\n\r\n            /* ---- correo ---- */\r\n            Subtitle(text = \"Correo electrónico:\")\r\n            InputText(\r\n                value         = user.email,\r\n                onValueChange = {},\r\n                modifier      = Modifier\r\n                    .fillMaxWidth()\r\n                    .padding(top = 8.dp)\r\n            )\r\n\r\n            Spacer(Modifier.height(22.dp))\r\n\r\n            /* ---- botones ---- */\r\n            Row(\r\n                Modifier.fillMaxWidth(),\r\n                horizontalArrangement = Arrangement.spacedBy(10.dp),\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                SecondaryButton(\r\n                    text = \"Editar perfil\",\r\n                    onClick = onEdit,\r\n                    modifier = Modifier.weight(1f)\r\n                )\r\n                ImageContainer(\r\n                    resId = R.drawable.ic_viewprofile,\r\n                    contentDescription = \"Cerrar sesión\",\r\n                    modifier = Modifier\r\n                        .size(120.dp)\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/* helper para pantalla centrada */\r\n@Composable\r\nprivate fun Centered(text: String) =\r\n    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\r\n        Description(text = text)\r\n    }\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/app/tibibalance/ui/screens/profile/show/ViewProfileScreen.kt b/app/src/main/java/com/app/tibibalance/ui/screens/profile/show/ViewProfileScreen.kt
--- a/app/src/main/java/com/app/tibibalance/ui/screens/profile/show/ViewProfileScreen.kt	(revision 889c681cbf682cefeecddf8b736a6c46c8572918)
+++ b/app/src/main/java/com/app/tibibalance/ui/screens/profile/show/ViewProfileScreen.kt	(date 1748761801070)
@@ -39,6 +39,14 @@
 import com.app.tibibalance.ui.theme.gradient
 import kotlinx.datetime.toJavaLocalDate
 import java.time.format.DateTimeFormatter
+import androidx.compose.runtime.*
+import androidx.compose.material3.AlertDialog
+import androidx.compose.material3.Text
+import androidx.compose.material3.Button
+import androidx.compose.ui.res.painterResource
+import androidx.compose.foundation.Image
+import androidx.compose.foundation.clickable
+
 
 @RequiresApi(Build.VERSION_CODES.O)
 @Composable
@@ -74,6 +82,9 @@
     onEdit    : () -> Unit,
     onSignOut : () -> Unit
 ) {
+    var taps by remember { mutableStateOf(0) }
+    var showScreamer by remember { mutableStateOf(false) }
+
     Column(
         modifier = Modifier
             .fillMaxSize()
@@ -153,6 +164,13 @@
                     contentDescription = "Cerrar sesión",
                     modifier = Modifier
                         .size(120.dp)
+                        .clickable {
+                            taps++
+                            if (taps >= 6) {
+                                showScreamer = true
+                                taps = 0
+                            }
+                        }
                 )
             }
         }
Index: domain/src/main/java/com/app/domain/repository/AuthRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.app.domain.repository\r\n\r\nimport com.app.domain.error.AuthResult\r\nimport com.app.domain.model.UserCredentials\r\nimport kotlinx.coroutines.flow.Flow\r\nimport kotlinx.datetime.LocalDate\r\n\r\n/**\r\n * Contrato de autenticación para Firebase.\r\n */\r\ninterface AuthRepository {\r\n    fun authState(): Flow<String?>\r\n\r\n    suspend fun signUp(\r\n        credentials : UserCredentials,\r\n        displayName : String,\r\n        birthDate   : LocalDate\r\n    ): AuthResult<Unit>\r\n\r\n    suspend fun signIn(credentials: UserCredentials): AuthResult<Boolean>\r\n    suspend fun signInWithGoogle(idToken: String): AuthResult<Boolean>\r\n    suspend fun sendPasswordReset(email: String): AuthResult<Unit>\r\n    suspend fun isEmailVerified(): Boolean\r\n    suspend fun changePassword(\r\n        currentPassword: String,\r\n        newPassword    : String\r\n    ): AuthResult<Unit>\r\n    suspend fun signOut()\r\n    suspend fun sendEmailVerification(): AuthResult<Unit>\r\n    suspend fun reload(): AuthResult<Unit>\r\n    suspend fun syncVerification(): AuthResult<Unit>\r\n    fun currentProvider(): String?\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/domain/src/main/java/com/app/domain/repository/AuthRepository.kt b/domain/src/main/java/com/app/domain/repository/AuthRepository.kt
--- a/domain/src/main/java/com/app/domain/repository/AuthRepository.kt	(revision 889c681cbf682cefeecddf8b736a6c46c8572918)
+++ b/domain/src/main/java/com/app/domain/repository/AuthRepository.kt	(date 1748762231495)
@@ -30,5 +30,7 @@
     suspend fun reload(): AuthResult<Unit>
     suspend fun syncVerification(): AuthResult<Unit>
     fun currentProvider(): String?
+
+    suspend fun deleteAccount(): Result<Unit>
 }
 
Index: app/src/main/java/com/app/tibibalance/ui/screens/habits/addHabitWizard/AddHabitViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.app.tibibalance.ui.screens.habits.addHabitWizard\r\n\r\nimport android.os.Build\r\nimport androidx.annotation.RequiresApi\r\nimport androidx.lifecycle.ViewModel\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.app.data.mappers.toForm\r\nimport com.app.data.mappers.toHabit\r\nimport com.app.domain.config.RepeatPreset\r\nimport com.app.domain.entities.Habit\r\nimport com.app.domain.model.HabitForm\r\nimport com.app.domain.enums.PeriodUnit\r\nimport com.app.domain.enums.SessionUnit\r\nimport com.app.domain.usecase.habit.CreateHabit\r\nimport com.app.domain.usecase.habit.GetSuggestedHabits\r\nimport dagger.hilt.android.lifecycle.HiltViewModel\r\nimport kotlinx.coroutines.channels.Channel\r\nimport kotlinx.coroutines.flow.*\r\nimport kotlinx.coroutines.launch\r\nimport javax.inject.Inject\r\n\r\n\r\nimport android.content.Context\r\nimport androidx.work.WorkManager\r\nimport com.app.domain.repository.AuthRepository\r\nimport com.app.domain.usecase.habit.GetHabitsFlow\r\nimport com.app.domain.usecase.user.UnlockAchievementUseCase\r\nimport com.app.tibibalance.sync.EvaluarLogrosWorker\r\nimport com.app.tibibalance.ui.screens.settings.achievements.AchievementUnlocked\r\n\r\n\r\n@HiltViewModel\r\nclass AddHabitViewModel @Inject constructor(\r\n    private val createHabit : CreateHabit,\r\n    getSuggested           : GetSuggestedHabits,\r\n    private val unlockAchievement: UnlockAchievementUseCase,\r\n    private val auth: AuthRepository,\r\n    private val getHabitsFlow: GetHabitsFlow\r\n) : ViewModel() {\r\n\r\n    private val _ui = MutableStateFlow(AddHabitUiState())\r\n    val ui: StateFlow<AddHabitUiState> = _ui.asStateFlow()\r\n\r\n    val suggestions = getSuggested()\r\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5_000), emptyList())\r\n\r\n    /* ---------- actualización del formulario ---------- */\r\n    fun updateForm(newForm: HabitForm) = _ui.update {\r\n        it.copy(form = newForm, hasChanges = true)\r\n    }\r\n\r\n    private fun resetState() { _ui.value = AddHabitUiState() }\r\n\r\n    /* ---------- navegación ---------- */\r\n    fun next() = _ui.update {\r\n        if (isStepValid(it.currentStep, it.form))\r\n            it.copy(currentStep = (it.currentStep + 1).coerceAtMost(3))\r\n        else it\r\n    }\r\n    fun back()  = _ui.update { it.copy(currentStep = (it.currentStep - 1).coerceAtLeast(0)) }\r\n\r\n    /* ---------- cierre del modal ---------- */\r\n    fun requestExit() {\r\n        val state = _ui.value\r\n        if (state.hasChanges || state.saving) {\r\n            /* hay cambios → pedimos confirmación */\r\n            _ui.update { it.copy(askExit = true) }\r\n        } else {\r\n            /* limpio → cerrar de inmediato */\r\n            _events.trySend(WizardEvent.Dismiss)\r\n        }\r\n    }\r\n\r\n\r\n    fun confirmExit(confirm: Boolean) {\r\n        if (confirm) {\r\n            resetState()\r\n            _events.trySend(WizardEvent.Dismiss)\r\n        }\r\n        _ui.update { it.copy(askExit = false) }\r\n    }\r\n\r\n    /* ---------- plantillas ---------- */\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    fun pickSuggestion(habit: Habit) = _ui.update {\r\n        if (it.hasChanges) it.copy(askReplace = true, tempTpl = habit)\r\n        else it.applyTemplate(habit)\r\n    }\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    fun confirmReplace(confirm: Boolean) = _ui.update {\r\n        if (confirm && it.tempTpl != null) it.applyTemplate(it.tempTpl!!)\r\n        else it.copy(askReplace = false, tempTpl = null)\r\n    }\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    private fun AddHabitUiState.applyTemplate(h: Habit) = copy(\r\n        askReplace = false,\r\n        tempTpl    = null,\r\n        form       = h.toForm(),\r\n        hasChanges = true,\r\n        currentStep = 1\r\n    )\r\n\r\n    /* ---------- guardado ---------- */\r\n    /*@RequiresApi(Build.VERSION_CODES.O)\r\n    fun save() = viewModelScope.launch {\r\n        val state = _ui.updateAndGet { it.copy(saving = true) }\r\n        runCatching { createHabit(state.form.toHabit()) }\r\n            .onSuccess {\r\n                /* mostramos diálogo de éxito */\r\n                _ui.value = AddHabitUiState(savedOk = true)\r\n\r\n            }\r\n            .onFailure { ex ->\r\n                _ui.update { it.copy(saving = false, errorMsg = ex.message) }\r\n            }\r\n    }*/\r\n\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    fun save(context: Context) = viewModelScope.launch {\r\n        val uid = auth.authState().first() ?: return@launch\r\n        val state = _ui.updateAndGet { it.copy(saving = true) }\r\n\r\n        runCatching {\r\n            val habit = state.form.toHabit()\r\n            createHabit(habit)\r\n\r\n            // --- Lógica de desbloqueo según categoría ---\r\n            val logro = when (habit.category.name.lowercase()) {\r\n                \"salud\" -> AchievementUnlocked(\r\n                    id = \"tibio_salud\",\r\n                    name = \"Tibio saludable\",\r\n                    description = \"Agrega un hábito de salud.\"\r\n                )\r\n                \"productividad\" -> AchievementUnlocked(\r\n                    id = \"tibio_productividad\",\r\n                    name = \"Tibio productivo\",\r\n                    description = \"Agrega un hábito de productividad.\"\r\n                )\r\n                \"bienestar\" -> AchievementUnlocked(\r\n                    id = \"tibio_bienestar\",\r\n                    name = \"Tibio del bienestar\",\r\n                    description = \"Agrega un hábito de bienestar.\"\r\n                )\r\n                else -> null\r\n            }\r\n\r\n            logro?.let {\r\n                if (unlockAchievement(uid, it.id)) {\r\n                    pushAchievement(it)\r\n                }\r\n            }\r\n\r\n            // Verifica logros por hábitos con modo reto activado\r\n            // Verifica logros por hábitos con modo reto activado\r\n            getHabitsFlow().first()\r\n                .filter { it.challenge != null }\r\n                .let { retos ->\r\n\r\n                    // Calcula progreso (mínimo 1 reto = 33%, máximo 3 retos = 100%)\r\n                    val progreso = (retos.size.coerceAtMost(5) * 20)\r\n\r\n                    // Si aún no llega al 100%, solo actualiza progreso\r\n                    if (progreso < 100) {\r\n                        unlockAchievement.updateProgress(uid, \"cinco_habitos\", progreso)\r\n                    } else {\r\n                        val l3 = AchievementUnlocked(\r\n                            id = \"cinco_habitos\",\r\n                            name = \"La sendera del reto\",\r\n                            description = \"Agrega cinco hábitos con modo reto activado.\"\r\n                        )\r\n                        if (unlockAchievement(uid, l3.id)) {\r\n                            pushAchievement(l3)\r\n                        }\r\n                    }\r\n\r\n                    // Manejo independiente del de \"primer_habito\"\r\n                    if (retos.size == 1) {\r\n                        val l1 = AchievementUnlocked(\r\n                            id = \"primer_habito\",\r\n                            name = \"El inicio del reto\",\r\n                            description = \"Agrega tu primer hábito con modo reto activado.\"\r\n                        )\r\n                        if (unlockAchievement(uid, l1.id)) {\r\n                            pushAchievement(l1)\r\n                        }\r\n                    }\r\n                }\r\n\r\n            // Lanza Worker (si sigue siendo necesario)\r\n            val work = EvaluarLogrosWorker.oneTime(uid)\r\n            WorkManager.getInstance(context).enqueue(work)\r\n\r\n            // Notifica éxito\r\n            _ui.value = AddHabitUiState(savedOk = true)\r\n        }.onFailure { ex ->\r\n            _ui.update { it.copy(saving = false, errorMsg = ex.message) }\r\n        }\r\n        _ui.value = AddHabitUiState(savedOk = true)\r\n    }\r\n\r\n\r\n\r\n    /* ---------- validaciones ---------- */\r\n    fun isStepValid(step: Int, f: HabitForm): Boolean = when (step) {\r\n        /* Paso 1 – nombre obligatorio */\r\n        1 -> f.name.isNotBlank()\r\n\r\n        /* Paso 2 – seguimiento */\r\n        2 -> when {\r\n            /* reto exige periodo definido */\r\n            f.challenge &&\r\n                    (f.periodUnit == PeriodUnit.INDEFINIDO || f.periodQty == null)          -> false\r\n\r\n            /* repetición personalizada exige días */\r\n            f.repeatPreset == RepeatPreset.PERSONALIZADO && f.weekDays.isEmpty()        -> false\r\n\r\n            /* si el usuario eligió unidad de periodo, debe poner cantidad */\r\n            f.periodUnit != PeriodUnit.INDEFINIDO && f.periodQty == null               -> false\r\n\r\n            /* si eligió unidad de sesión, debe poner cantidad */\r\n            f.sessionUnit != SessionUnit.INDEFINIDO && f.sessionQty == null            -> false\r\n\r\n            else -> true\r\n        }\r\n\r\n        /* Paso 3 – si “notificar” está activo, al menos una hora */\r\n        3 -> !f.notify || f.notifTimes.isNotEmpty()\r\n\r\n        else -> true\r\n    }\r\n\r\n    fun acknowledgeSaved() {\r\n        resetState()                                // ← vuelve todo a paso 0\r\n        _events.trySend(WizardEvent.Dismiss)        // ← cierra el modal\r\n    }\r\n\r\n    fun consumeSaved() {\r\n        _ui.update { it.copy(savedOk = false) }\r\n    }\r\n\r\n    /* ---------- canal eventos ---------- */\r\n    private val _events = Channel<WizardEvent>(Channel.BUFFERED)\r\n    val events = _events.receiveAsFlow()\r\n\r\n    private val _pendingAchievements = mutableListOf<AchievementUnlocked>()\r\n\r\n    fun popNextAchievement(): AchievementUnlocked? =\r\n        _pendingAchievements.removeFirstOrNull()\r\n\r\n    private fun pushAchievement(logro: AchievementUnlocked) {\r\n        _pendingAchievements.add(logro)\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/app/tibibalance/ui/screens/habits/addHabitWizard/AddHabitViewModel.kt b/app/src/main/java/com/app/tibibalance/ui/screens/habits/addHabitWizard/AddHabitViewModel.kt
--- a/app/src/main/java/com/app/tibibalance/ui/screens/habits/addHabitWizard/AddHabitViewModel.kt	(revision 889c681cbf682cefeecddf8b736a6c46c8572918)
+++ b/app/src/main/java/com/app/tibibalance/ui/screens/habits/addHabitWizard/AddHabitViewModel.kt	(date 1748760986911)
@@ -25,7 +25,6 @@
 import com.app.domain.repository.AuthRepository
 import com.app.domain.usecase.habit.GetHabitsFlow
 import com.app.domain.usecase.user.UnlockAchievementUseCase
-import com.app.tibibalance.sync.EvaluarLogrosWorker
 import com.app.tibibalance.ui.screens.settings.achievements.AchievementUnlocked
 
 
@@ -187,8 +186,8 @@
                 }
 
             // Lanza Worker (si sigue siendo necesario)
-            val work = EvaluarLogrosWorker.oneTime(uid)
-            WorkManager.getInstance(context).enqueue(work)
+            //val work = EvaluarLogrosWorker.oneTime(uid)
+            //WorkManager.getInstance(context).enqueue(work)
 
             // Notifica éxito
             _ui.value = AddHabitUiState(savedOk = true)
Index: data/src/main/java/com/app/data/repository/AuthRepositoryImpl.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.app.data.repository\r\n\r\nimport android.os.Build\r\nimport androidx.annotation.RequiresApi\r\nimport com.app.data.mappers.toAuthError\r\nimport com.app.data.mappers.toFirestoreMap\r\nimport com.app.domain.common.SyncMeta\r\nimport com.app.domain.entities.User\r\nimport com.app.domain.entities.UserSettings\r\nimport com.app.domain.enums.ThemeMode\r\nimport com.app.domain.error.AuthError\r\nimport com.app.domain.error.AuthResult\r\nimport com.app.domain.model.UserCredentials\r\nimport com.app.domain.repository.AuthRepository\r\nimport com.google.firebase.auth.EmailAuthProvider\r\nimport com.google.firebase.auth.FirebaseAuth\r\nimport com.google.firebase.auth.FirebaseAuthProvider\r\nimport com.google.firebase.auth.FirebaseUser\r\nimport com.google.firebase.auth.GoogleAuthProvider\r\nimport com.google.firebase.firestore.FirebaseFirestore\r\nimport com.google.firebase.firestore.SetOptions\r\nimport kotlinx.coroutines.channels.awaitClose\r\nimport kotlinx.coroutines.flow.Flow\r\nimport kotlinx.coroutines.flow.callbackFlow\r\nimport kotlinx.coroutines.tasks.await\r\nimport kotlinx.datetime.Clock\r\nimport kotlinx.datetime.LocalDate\r\nimport kotlinx.datetime.TimeZone\r\nimport kotlinx.datetime.toKotlinLocalDate\r\nimport kotlinx.datetime.toLocalDateTime\r\nimport javax.inject.Inject\r\nimport javax.inject.Singleton\r\nimport java.net.HttpURLConnection\r\nimport java.net.URL\r\nimport org.json.JSONObject\r\nimport android.util.Log\r\n\r\n@Singleton\r\nclass AuthRepositoryImpl @Inject constructor(\r\n    private val auth: FirebaseAuth,\r\n    private val firestore: FirebaseFirestore\r\n) : AuthRepository {\r\n\r\n    /* ── Estado de sesión ───────────────────────────────────────── */\r\n    override fun authState(): Flow<String?> = callbackFlow {\r\n        val listener = FirebaseAuth.AuthStateListener { a -> trySend(a.currentUser?.uid) }\r\n        auth.addAuthStateListener(listener)\r\n        awaitClose { auth.removeAuthStateListener(listener) }\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    override suspend fun signUp(\r\n        credentials: UserCredentials,\r\n        displayName: String,\r\n        birthDate  : LocalDate\r\n    ): AuthResult<Unit> {\r\n        return try {\r\n            auth.createUserWithEmailAndPassword(credentials.email, credentials.password).await()\r\n            val emailSent = auth.currentUser?.email?.let { sendVerificationEmailBackend(it) } ?: false\r\n            if (!emailSent) {\r\n                return AuthResult.Error(AuthError.Unknown(Exception(\"Error enviando correo de verificación desde backend\")))\r\n            }\r\n            auth.currentUser?.let { firestore.ensureUserDocument(it, displayName, birthDate) }\r\n            AuthResult.Success(Unit)\r\n        } catch (t: Throwable) { AuthResult.Error(t.toAuthError()) }\r\n    }\r\n\r\n    /* ── Inicio de sesión e-mail / pass ────────────────────────── */\r\n    override suspend fun signIn(credentials: UserCredentials): AuthResult<Boolean> =\r\n        try {\r\n            auth.signInWithEmailAndPassword(credentials.email, credentials.password).await()\r\n            AuthResult.Success(auth.currentUser?.isEmailVerified == true)\r\n        } catch (t: Throwable) {\r\n            AuthResult.Error(t.toAuthError())\r\n        }\r\n\r\n    /* ── Google One-Tap ─────────────────────────────────────────── */\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    override suspend fun signInWithGoogle(idToken: String): AuthResult<Boolean> = try {\r\n        val cred = GoogleAuthProvider.getCredential(idToken, null)\r\n        auth.signInWithCredential(cred).await()\r\n\r\n        // user nunca es null tras cred exitosa\r\n        auth.currentUser?.let { firestore.ensureUserDocument(it) }\r\n\r\n        AuthResult.Success(true)\r\n    } catch (t: Throwable) {\r\n        AuthResult.Error(t.toAuthError())\r\n    }\r\n\r\n\r\n    /* ── Restablecer contraseña ────────────────────────────────── */\r\n    override suspend fun sendPasswordReset(email: String): AuthResult<Unit> =\r\n        try {\r\n            auth.sendPasswordResetEmail(email).await()\r\n            AuthResult.Success(Unit)\r\n        } catch (t: Throwable) {\r\n            AuthResult.Error(t.toAuthError())\r\n        }\r\n\r\n    /* ── Verificación directa ──────────────────────────────────── */\r\n    override suspend fun isEmailVerified(): Boolean =\r\n        auth.currentUser?.isEmailVerified == true    // single-source-of-truth\r\n\r\n    override suspend fun sendEmailVerification(): AuthResult<Unit> {\r\n        return try {\r\n            val emailSent = auth.currentUser?.email?.let { sendVerificationEmailBackend(it) } ?: false\r\n            if (!emailSent) {\r\n                return AuthResult.Error(AuthError.Unknown(Exception(\"Error enviando correo de verificación desde backend\")))\r\n            }\r\n            AuthResult.Success(Unit)\r\n        } catch (t: Throwable) { AuthResult.Error(t.toAuthError()) }\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    override suspend fun changePassword(\r\n        currentPassword: String,\r\n        newPassword   : String\r\n    ): AuthResult<Unit> {\r\n        return try {\r\n            val user = auth.currentUser\r\n                ?: return AuthResult.Error(AuthError.Unknown(IllegalStateException(\"No user\")))\r\n\r\n            /* 1\uFE0F⃣  Sólo aplica a cuentas Email/Password --------------------------- */\r\n            val email = user.email\r\n            val provider = currentProvider()\r\n            if (provider != EmailAuthProvider.PROVIDER_ID) {\r\n                return AuthResult.Error(AuthError.Unknown(IllegalStateException(\"Wrong provider\")))\r\n            }\r\n\r\n            /* 2\uFE0F⃣  Re-authenticate ------------------------------------------------- */\r\n            val cred = EmailAuthProvider.getCredential(email!!, currentPassword)\r\n            user.reauthenticate(cred).await()                // lanza si falla pwd\r\n\r\n            /* 3\uFE0F⃣  Actualiza la contraseña ---------------------------------------- */\r\n            user.updatePassword(newPassword).await()\r\n\r\n            AuthResult.Success(Unit)\r\n        } catch (t: Throwable) {\r\n            AuthResult.Error(t.toAuthError())\r\n        }\r\n    }\r\n\r\n\r\n    override suspend fun reload(): AuthResult<Unit> = try {\r\n        auth.currentUser?.reload()?.await()\r\n        AuthResult.Success(Unit)\r\n    } catch (t: Throwable) { AuthResult.Error(t.toAuthError()) }\r\n\r\n\r\n    override suspend fun signOut() = auth.signOut()\r\n\r\n    /* ── Sincroniza bandera emailVerified en Firestore ─────────── */\r\n    override suspend fun syncVerification(): AuthResult<Unit> {\r\n        return try {\r\n            val user = auth.currentUser\r\n                ?: return AuthResult.Error(AuthError.Unknown(IllegalStateException(\"No user\")))\r\n            if (!user.isEmailVerified) return AuthResult.Success(Unit)\r\n\r\n            firestore.collection(\"users\")\r\n                .document(user.uid)\r\n                .update(\"emailVerified\", true)\r\n                .await()\r\n            AuthResult.Success(Unit)\r\n        } catch (t: Throwable) {\r\n            AuthResult.Error(t.toAuthError())\r\n        }\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    suspend fun FirebaseFirestore.ensureUserDocument(user: FirebaseUser) {\r\n        val uid = user.uid\r\n        val docRef = collection(\"users\").document(uid)\r\n        val snap   = docRef.get().await()\r\n        if (snap.exists()) return                    // ya registrado ✅\r\n\r\n        val dob = java.time.LocalDate.now().minusYears(18).toKotlinLocalDate()\r\n\r\n        val sync = SyncMeta(\r\n            createdAt  = Clock.System.now(),\r\n            updatedAt  = Clock.System.now(),\r\n            deletedAt  = null,\r\n            pendingSync = false\r\n        )\r\n\r\n        val settings = UserSettings(\r\n            theme            = ThemeMode.SYSTEM,\r\n            notifGlobal      = true,\r\n            language         = \"es\",\r\n            accessibilityTTS = false\r\n        )\r\n\r\n        val newUser = User(\r\n            uid         = uid,\r\n            email       = user.email ?: \"\",\r\n            displayName = user.displayName,\r\n            photoUrl    = user.photoUrl?.toString(),\r\n            birthDate   = dob,\r\n            settings    = settings,\r\n            meta        = sync\r\n        ).toFirestoreMap()\r\n\r\n        docRef.set(newUser, SetOptions.merge()).await()\r\n    }\r\n\r\n    @RequiresApi(Build.VERSION_CODES.O)\r\n    suspend fun FirebaseFirestore.ensureUserDocument(\r\n        user        : FirebaseUser,\r\n        displayName : String?      = null,\r\n        birthDate   : LocalDate?   = null\r\n    ) {\r\n        val doc = collection(\"users\").document(user.uid)\r\n        if (doc.get().await().exists()) return            // ya existe ⇒ nada que hacer\r\n\r\n        /* Usa los valores recibidos; si vienen nulos aplica fallback */\r\n        val dob   = birthDate ?: java.time.LocalDate.now().minusYears(18)\r\n            .toKotlinLocalDate()\r\n        val name  = displayName ?: user.displayName\r\n\r\n        val meta = SyncMeta(\r\n            createdAt  = Clock.System.now(),\r\n            updatedAt  = Clock.System.now(),\r\n            deletedAt  = null,\r\n            pendingSync = false\r\n        )\r\n        val settings = UserSettings(\r\n            theme            = ThemeMode.SYSTEM,\r\n            notifGlobal      = true,\r\n            language         = \"es\",\r\n            accessibilityTTS = false\r\n        )\r\n        val newUser = User(\r\n            uid         = user.uid,\r\n            email       = user.email ?: \"\",\r\n            displayName = name,\r\n            photoUrl    = user.photoUrl?.toString(),\r\n            birthDate   = dob,\r\n            settings    = settings,\r\n            meta        = meta\r\n        ).toFirestoreMap()\r\n\r\n        doc.set(newUser, SetOptions.merge()).await()\r\n    }\r\n\r\n    /* Función para enviar el correo desde el backend de Node.js */\r\n    private fun sendVerificationEmailBackend(email: String): Boolean {\r\n        return try {\r\n            val url = URL(\"https://tibiserver.onrender.com/send-confirmation\")\r\n            val connection = url.openConnection() as HttpURLConnection\r\n            connection.requestMethod = \"POST\"\r\n            connection.setRequestProperty(\"Content-Type\", \"application/json\")\r\n            connection.doOutput = true\r\n\r\n            val json = JSONObject().apply {\r\n                put(\"email\", email)\r\n            }\r\n\r\n            connection.outputStream.use {\r\n                it.write(json.toString().toByteArray())\r\n            }\r\n\r\n            val responseCode = connection.responseCode\r\n            val responseMessage = connection.inputStream.bufferedReader().use { it.readText() }\r\n            connection.disconnect()\r\n\r\n            if (responseCode in 200..299) {\r\n                Log.i(\"AuthRepo\", \"Correo de verificación enviado correctamente para $email\")\r\n                true\r\n            } else {\r\n                Log.e(\"AuthRepo\", \"Error enviando correo de verificación: Código $responseCode - $responseMessage\")\r\n                false\r\n            }\r\n        } catch (e: Exception) {\r\n            Log.e(\"AuthRepo\", \"Error enviando correo de verificación al backend: ${e.message}\", e)\r\n            false\r\n        }\r\n    }\r\n\r\n    override fun currentProvider(): String? =\r\n        auth.currentUser                     // FirebaseUser?\r\n            ?.providerData                   // lista de UserInfo (incluye “firebase”)\r\n            ?.firstOrNull { it.providerId != FirebaseAuthProvider.PROVIDER_ID }  // omite entry “firebase”\r\n            ?.providerId\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/data/src/main/java/com/app/data/repository/AuthRepositoryImpl.kt b/data/src/main/java/com/app/data/repository/AuthRepositoryImpl.kt
--- a/data/src/main/java/com/app/data/repository/AuthRepositoryImpl.kt	(revision 889c681cbf682cefeecddf8b736a6c46c8572918)
+++ b/data/src/main/java/com/app/data/repository/AuthRepositoryImpl.kt	(date 1748762231510)
@@ -281,4 +281,14 @@
             ?.providerData                   // lista de UserInfo (incluye “firebase”)
             ?.firstOrNull { it.providerId != FirebaseAuthProvider.PROVIDER_ID }  // omite entry “firebase”
             ?.providerId
+
+    override suspend fun deleteAccount(): Result<Unit> {
+        val user = FirebaseAuth.getInstance().currentUser
+        return try {
+            user?.delete()?.await()
+            Result.success(Unit)
+        } catch (e: Exception) {
+            Result.failure(e)
+        }
+    }
 }
